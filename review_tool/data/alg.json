{
    "二叉树": [
        {
            "cost_time": 10,
            "desc": "二叉树先序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "id": "1",
            "last_time": 1563521416,
            "times": 2
        },
        {
            "cost_time": 10,
            "desc": "二叉树中序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "id": "2",
            "last_time": 1563427003,
            "times": 1
        },
        {
            "cost_time": 10,
            "desc": "二叉树后序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "id": "3",
            "last_time": 1563419866,
            "times": 1
        },
        {
            "cost_time": 15,
            "desc": "二叉树先序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "id": "4",
            "last_time": 1563347876,
            "times": 1
        },
        {
            "cost_time": 15,
            "desc": "二叉树中序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "id": "5",
            "last_time": 1563419866,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "二叉树后序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "id": "6",
            "last_time": 1563521416,
            "times": 2
        },
        {
            "cost_time": 20,
            "desc": "打印二叉树边界节点 - 标准 1: (1, 头节点为边界节点; 2, 叶节点为边界节点; 3, 如果节点在其所在的层中是最左或最右边的, 那么也是边界节点) ",
            "diff": 2,
            "id": "7",
            "last_time": 1563521416,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "打印二叉树边界节点 - 标准 2: (1, 头节点为边界节点; 2, 叶节点为边界节点, 树左边界延伸下去的路径为边界节点; 3, 树右边延伸下去的路径为边界节点)",
            "diff": 2,
            "id": "8",
            "last_time": 1563427003,
            "times": 1
        },
        {
            "cost_time": 40,
            "desc": "直观的打印二叉树",
            "diff": 3,
            "id": "9",
            "last_time": 1563347876,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "二叉树序列化和反序列化 - 先序遍历 - 递归实现",
            "diff": 2,
            "id": "10",
            "last_time": 1563517100,
            "times": 1
        },
        {
            "cost_time": 30,
            "desc": "二叉树序列化和反序列化 - 先序遍历 - 非递归实现, 空间 O(n)",
            "diff": 2,
            "id": "11",
            "last_time": 1563419866,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "二叉树序列化和反序列化 - 层次遍历",
            "diff": 2,
            "id": "12",
            "last_time": 1563517100,
            "times": 1
        },
        {
            "cost_time": 50,
            "desc": "在二叉树中找到累加和为指定值的最长路径长度, 节点值可正可负",
            "diff": 3,
            "id": "13",
            "last_time": 1563427003,
            "times": 1
        },
        {
            "cost_time": 30,
            "desc": "找到二叉树中的最大搜索二叉树",
            "diff": 3,
            "id": "14",
            "last_time": 1563521416,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "在二叉树中找到累加和为指定值的一条路径, 节点值可正可负",
            "diff": 2,
            "id": "15",
            "last_time": 1563427003,
            "times": 1
        },
        {
            "cost_time": 15,
            "desc": "给定一个二叉树节点，找到它在中序遍历中的下一个节点",
            "diff": 2,
            "id": "16",
            "last_time": 1563347876,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "判断二叉树是否是对称结构",
            "diff": 1,
            "id": "17",
            "last_time": 1563517100,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "给定一个大树头节点, 和一棵小树头节点, 判断大树是否包含小树",
            "diff": 1,
            "id": "18",
            "last_time": 1563419866,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "树中两个节点的最低公共祖先 - 二叉搜索树",
            "diff": 2,
            "id": "19",
            "last_time": 1563347876,
            "times": 1
        },
        {
            "cost_time": 50,
            "desc": "树中两个节点的最低公共祖先 - 普通树 - 没有父指针",
            "diff": 2,
            "id": "20",
            "last_time": 1563322177,
            "times": 1
        },
        {
            "cost_time": 25,
            "desc": "树中两个节点的最低公共祖先 - 普通树 - 有父指针",
            "diff": 2,
            "id": "21",
            "last_time": 1563322177,
            "times": 1
        },
        {
            "cost_time": 10,
            "desc": "反转二叉树",
            "diff": 1,
            "id": "22",
            "last_time": 1563427003,
            "times": 1
        },
        {
            "cost_time": 30,
            "desc": "使用二叉树的先序和中序序列重建二叉树",
            "diff": 2,
            "id": "23",
            "last_time": 1563521416,
            "times": 1
        },
        {
            "cost_time": 20,
            "desc": "找到二叉树中符合二叉树搜索条件的最大拓扑结构",
            "diff": 3,
            "id": "24",
            "last_time": 1563322177,
            "times": 1
        },
        {
            "cost_time": 10,
            "desc": "二叉树按层打印，需要换行",
            "diff": 1,
            "id": "25",
            "last_time": 1563322177,
            "times": 1
        },
        {
            "cost_time": 10,
            "desc": "二叉树按层以 zigzag 方式打印，需要换行 - 双栈方法",
            "diff": 1,
            "id": "26",
            "last_time": 1563347876,
            "times": 1
        },
        {
            "cost_time": 15,
            "desc": "二叉树按层以 zigzag 方式打印，需要换行 - 双端队列方法",
            "diff": 2,
            "id": "27",
            "last_time": 1563322177,
            "times": 1
        }
    ],
    "字符串": [
        {
            "cost_time": 20,
            "desc": "大数相加",
            "diff": 1,
            "id": "28",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "012345678910111213...这样的数字字符串的第 n 位是什么?",
            "diff": 2,
            "id": "29",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "在字符串 A 中删除所有在字符串 B 中存在的字符",
            "diff": 1,
            "id": "30",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "删除字符串 A 中所有重复字符",
            "diff": 1,
            "id": "31",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "在字符串中找出第一个只出现 1 次的字符",
            "diff": 1,
            "id": "32",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在字符流中找出第一个只出现 1 次的字符",
            "diff": 2,
            "id": "33",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两个字符串是否是 anagram",
            "diff": 1,
            "id": "34",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "翻转英文句子中单词的顺序，但单词内字符顺序不能发生改变",
            "diff": 1,
            "id": "35",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "字符串转 int",
            "diff": 1,
            "id": "36",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "左旋转字符串",
            "diff": 1,
            "id": "37",
            "last_time": 0,
            "times": 0
        }
    ],
    "数组": [
        {
            "cost_time": 20,
            "desc": "找到数组中累加和为指定值的最长序列, 元素皆为正数",
            "diff": 1,
            "id": "38",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "找到数组中累加和为指定值的最长序列, 元素可正可负",
            "diff": 2,
            "id": "39",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "将数组循环右移 k 位的结果",
            "diff": 1,
            "id": "40",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在二维有序数组中的查找给定值",
            "diff": 1,
            "id": "41",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "顺时针打印矩阵",
            "diff": 1,
            "id": "42",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "找出数组中超过一半的元素",
            "diff": 1,
            "id": "43",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到数组中连续子序列的最大和，元素可正可负",
            "diff": 2,
            "id": "44",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "调整数组使得数组中所有元素组成的字符串所表示的数值最小",
            "diff": 2,
            "id": "45",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "不修改数组的情况下, 找到数组中一个重复的元素，元素范围 1 ~ n, 个数 n+1",
            "diff": 2,
            "id": "46",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到数组中一个重复元素, 元素范围 0 ~ n, 个数 n+1",
            "diff": 2,
            "id": "47",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "整数数组中除了两个数字外，其余数字都出现了两次，找到这两个只出现一次的数字",
            "diff": 1,
            "id": "48",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "数组中除了一个数字只出现一次外，其他数字都出现了三次，找出只出现一次的那个数字",
            "diff": 1,
            "id": "49",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在自然数 {1,2,3,4...} 序列中打印出所有和为 s 的连续正数序列",
            "diff": 1,
            "id": "50",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找出数组中逆序对的数量",
            "diff": 1,
            "id": "51",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "调整数组使得奇数都在左边，偶数都在右边",
            "diff": 1,
            "id": "52",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "已排序数组中, 找出值和下标相等的元素",
            "diff": 1,
            "id": "53",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "数组个数 n-1, 范围 0 ~ n-1 中有且只有一个元素不在数组中，找出这个缺失元素。比如 0 1 2 4 5，缺失 3",
            "diff": 1,
            "id": "54",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "给定值 k, 在一个已排序数组中，统计 k 出现了多少次",
            "diff": 1,
            "id": "55",
            "last_time": 0,
            "times": 0
        }
    ],
    "栈和队列": [
        {
            "cost_time": 50,
            "desc": "实现有 get_min 接口的栈，要求: get_min 方法时间复杂度是 O(1)",
            "diff": 1,
            "id": "56",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_max 接口的栈，要求: get_max 方法时间复杂度是 O(1)",
            "diff": 1,
            "id": "57",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_min 接口的队列，要求: get_min 方法时间复杂度是 O(1)",
            "diff": 1,
            "id": "58",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_max 接口的队列，要求: get_max 方法时间复杂度是 O(1)",
            "diff": 1,
            "id": "59",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "用两个栈实现队列",
            "diff": 1,
            "id": "60",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "用两个队列实现栈",
            "diff": 1,
            "id": "61",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 25,
            "desc": "仅使用栈操作和递归翻转一个栈",
            "diff": 2,
            "id": "62",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "使用另一个辅助栈来完成对栈的排序，让元素从栈顶到栈底部升序排列",
            "diff": 2,
            "id": "63",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "滑动窗口的最大值",
            "diff": 1,
            "id": "64",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "用数组构建一棵 max_tree, 该树的每个父节点都是它所在子树中的最大值",
            "diff": 2,
            "id": "65",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "求 01 矩阵中, 由 1 所围成的最大矩阵面积",
            "diff": 1,
            "id": "66",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "最大值减去最小值小于或等于 num 的子数组数量",
            "diff": 3,
            "id": "67",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "给定一个压栈序列, 和一个弹出序列, 判断弹出序列是否合法",
            "diff": 1,
            "id": "68",
            "last_time": 0,
            "times": 0
        }
    ],
    "链表": [
        {
            "cost_time": 25,
            "desc": "打印两条有序链表中节点值相同的公共部分 (不要理解成相交链表的公共部分)",
            "diff": 1,
            "id": "69",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "单链表删除倒数第 k 个节点",
            "diff": 1,
            "id": "70",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "双向链表删除倒数第 k 个节点",
            "diff": 1,
            "id": "71",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "删除链表的中间节点",
            "diff": 1,
            "id": "72",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 25,
            "desc": "删除链表的 a/b 处的节点",
            "diff": 2,
            "id": "73",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "反转单向链表",
            "diff": 1,
            "id": "74",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "反转双向链表",
            "diff": 1,
            "id": "75",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "反转部分单向链表",
            "diff": 2,
            "id": "76",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "环形单链表约瑟夫问题",
            "diff": 1,
            "id": "77",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "约瑟夫问题套公式解法",
            "diff": 3,
            "id": "78",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "判断链表是否是回文结构",
            "diff": 1,
            "id": "79",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "将单向链表按某值划分为左边小, 中间相等, 右边大的形式",
            "diff": 1,
            "id": "80",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "复制含有随机指针节点的链表",
            "diff": 1,
            "id": "81",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "两个单链表生成相加链表 (链表节点值的范围是 0 ~ 9)",
            "diff": 1,
            "id": "82",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两条无环单链表是否相交",
            "diff": 1,
            "id": "83",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "判断链表是否有环, 若有，求出入口节点和环中节点数",
            "diff": 1,
            "id": "84",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两条有环单链表是否相交",
            "diff": 1,
            "id": "85",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "将单链表每 k 个节点之间逆序, 不够 k 个的区间不逆序",
            "diff": 2,
            "id": "86",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "删除无序单链表中重复出现的节点",
            "diff": 1,
            "id": "87",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "单向链表中, 删除指定值的所有节点",
            "diff": 1,
            "id": "88",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "搜索二叉树转换成双向链表",
            "diff": 1,
            "id": "89",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "单链表的选择排序",
            "diff": 1,
            "id": "90",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "O(1) 删除单链表指定节点",
            "diff": 1,
            "id": "91",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "向有序环形链表中插入新节点",
            "diff": 1,
            "id": "92",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "合并两个有序的单链表",
            "diff": 1,
            "id": "93",
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "按照 L1->R1->L2->R2..的方式重新组合单链表",
            "diff": 1,
            "id": "94",
            "last_time": 0,
            "times": 0
        }
    ]
}