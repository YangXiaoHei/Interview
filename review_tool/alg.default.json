{
    "二叉树": [
        {
            "cost_time": 10,
            "desc": "二叉树先序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 10,
            "desc": "二叉树中序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 10,
            "desc": "二叉树后序遍历 - 非递归 - 时间 O(n), 空间 O(n)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "二叉树先序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "二叉树中序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "二叉树后序遍历 - 非递归 - 时间 O(n), 空间 O(1)",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "打印二叉树边界节点 - 标准 1: ",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "打印二叉树边界节点 - 标准 2: ",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "直观的打印二叉树",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "二叉树序列化和反序列化 - 先序遍历 - 递归实现",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "二叉树序列化和反序列化 - 先序遍历 - 非递归实现, 空间 O(n)",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "二叉树序列化和反序列化 - 先序遍历 - 非递归实现, 空间 O(1)",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "二叉树序列化和反序列化 - 层次遍历",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在二叉树中找到累加和为指定值的最长路径长度, 节点值可正可负",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到二叉树中的最大搜索二叉树",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "在二叉树中找到累加和为指定值的一条路径, 节点值可正可负",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "给定一个二叉树节点，找到它在中序遍历中的下一个节点",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断二叉树是否是对称结构",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "给定一个大树头节点, 和一棵小树头节点, 判断大树是否包含小树",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "树中两个节点的最低公共祖先 - 二叉搜索树",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "树中两个节点的最低公共祖先 - 普通树 - 没有父指针",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 25,
            "desc": "树中两个节点的最低公共祖先 - 普通树 - 有父指针",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "反转二叉树",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "使用二叉树的先序和中序序列重建二叉树",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到二叉树中符合二叉树搜索条件的最大拓扑结构",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "二叉树按层打印，需要换行",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "二叉树按层以 zigzag 方式打印，需要换行 - 双栈方法",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "二叉树按层以 zigzag 方式打印，需要换行 - 双端队列方法",
            "diff": 2,
            "last_time": 0,
            "times": 0
        }
    ],
    "字符串": [
        {
            "cost_time": 20,
            "desc": "大数相加",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "012345678910111213...这样的数字字符串的第 n 位是什么?",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "在字符串 A 中删除所有在字符串 B 中存在的字符",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "删除字符串 A 中所有重复字符",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "在字符串中找出第一个只出现 1 次的字符",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在字符流中找出第一个只出现 1 次的字符",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两个字符串是否是 anagram",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "翻转英文句子中单词的顺序，但单词内字符顺序不能发生改变",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "字符串转 int",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "左旋转字符串",
            "diff": 1,
            "last_time": 0,
            "times": 0
        }
    ],
    "数组": [
        {
            "cost_time": 20,
            "desc": "找到数组中累加和为指定值的最长序列, 元素皆为正数",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "找到数组中累加和为指定值的最长序列, 元素可正可负",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "将数组循环右移 k 位的结果",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在二维有序数组中的查找给定值",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "顺时针打印矩阵",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "找出数组中超过一半的元素",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到数组中连续子序列的最大和，元素可正可负",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "调整数组使得数组中所有元素组成的字符串所表示的数值最小",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "不修改数组的情况下, 找到数组中一个重复的元素，元素范围 1 ~ n, 个数 n+1",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找到数组中一个重复元素, 元素范围 0 ~ n, 个数 n+1",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "整数数组中除了两个数字外，其余数字都出现了两次，找到这两个只出现一次的数字",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "数组中除了一个数字只出现一次外，其他数字都出现了三次，找出只出现一次的那个数字",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "在自然数 {1,2,3,4...} 序列中打印出所有和为 s 的连续正数序列",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "找出数组中逆序对的数量",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 15,
            "desc": "调整数组使得奇数都在左边，偶数都在右边",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "已排序数组中, 找出值和下标相等的元素",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "数组个数 n-1, 范围 0 ~ n-1 中有且只有一个元素不在数组中，找出这个缺失元素。比如 0 1 2 4 5，缺失 3",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "给定值 k, 在一个已排序数组中，统计 k 出现了多少次",
            "diff": 1,
            "last_time": 0,
            "times": 0
        }
    ],
    "栈和队列": [
        {
            "cost_time": 50,
            "desc": "实现有 get_min 接口的栈，要求: get_min 方法时间复杂度是 O(1)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_max 接口的栈，要求: get_max 方法时间复杂度是 O(1)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_min 接口的队列，要求: get_min 方法时间复杂度是 O(1)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "实现有 get_max 接口的队列，要求: get_max 方法时间复杂度是 O(1)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "用两个栈实现队列",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "用两个队列实现栈",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 25,
            "desc": "仅使用栈操作和递归翻转一个栈",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "使用另一个辅助栈来完成对栈的排序，让元素从栈顶到栈底部升序排列",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "滑动窗口的最大值",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "用数组构建一棵 max_tree, 该树的每个父节点都是它所在子树中的最大值",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "求 01 矩阵中, 由 1 所围成的最大矩阵面积",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "最大值减去最小值小于或等于 num 的子数组数量",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "给定一个压栈序列, 和一个弹出序列, 判断弹出序列是否合法",
            "diff": 1,
            "last_time": 0,
            "times": 0
        }
    ],
    "链表": [
        {
            "cost_time": 25,
            "desc": "打印两条有序链表中节点值相同的公共部分 (不要理解成相交链表的公共部分)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "单链表删除倒数第 k 个节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "双向链表删除倒数第 k 个节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "删除链表的中间节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 25,
            "desc": "删除链表的 a/b 处的节点",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "反转单向链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "反转双向链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "反转部分单向链表",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "环形单链表约瑟夫问题",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "约瑟夫问题套公式解法",
            "diff": 3,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "判断链表是否是回文结构",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "将单向链表按某值划分为左边小, 中间相等, 右边大的形式",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "复制含有随机指针节点的链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "两个单链表生成相加链表 (链表节点值的范围是 0 ~ 9)",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两条无环单链表是否相交",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "判断链表是否有环, 若有，求出入口节点和环中节点数",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "判断两条有环单链表是否相交",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "将单链表每 k 个节点之间逆序, 不够 k 个的区间不逆序",
            "diff": 2,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "删除无序单链表中重复出现的节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "单向链表中, 删除指定值的所有节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "搜索二叉树转换成双向链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "单链表的选择排序",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 30,
            "desc": "O(1) 删除单链表指定节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 40,
            "desc": "向有序环形链表中插入新节点",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 20,
            "desc": "合并两个有序的单链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        },
        {
            "cost_time": 50,
            "desc": "按照 L1->R1->L2->R2..的方式重新组合单链表",
            "diff": 1,
            "last_time": 0,
            "times": 0
        }
    ]
}